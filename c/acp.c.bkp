// C version of acp code

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include "LinkedListArray.h"
#include "LinkedList.h"
#include "hashsetint.h"

// input: quad (a quadruple of curvatures)
// output: solutions (list of transformed quadruples)
// function: this runs quadruples through the four transformations (one for each curvature), and records the new one only if the transformed curvature is bigger than the original (so a smaller circle in the packing)

hashset_t CURVELIST;

struct LinkedListArray* transform(int quad[4], int limit) {
	// TODO: We should combine transform and check struct LinkedListArray *solutions = llaInit();
    int a = quad[0], b = quad[1], c = quad[2], d = quad[3];
    int twice = (a + b + c + d) << 1; // very quick way to multiply by 2

    int transformed[4] = {0,0,0,0};
    transformed[0] = -3 * a + twice;
    transformed[1] = -3 * b + twice;
    transformed[2] = -3 * c + twice;
    transformed[3] = -3 * d + twice;

    int i = 0;
    for (i = 0; i < 4; i++)
    {
        if (quad[i] < transformed[i] < limit)
        {
            int prime[4];
            memcpy(prime, quad, 4*sizeof(int));
            prime[i] = transformed[i];
            llaAppend(solutions, nodeArrayInitWithArray(prime));
            hashset_add(CURVELIST, transformed[i]);
        }
    }

    return solutions;
    /*
    struct NodeArray *soln = NULL;
    if ((-a + (2 * (b + c + d))) > a) {
        soln = nodeArrayInitWithArray(((int [4]){(-a + (2 * (b + c + d))), b, c, d}));
        llaAppend(solutions, soln);
    }
    if ((-b + (2 * (a + c + d))) > b) {
        soln = nodeArrayInit();
        memcpy((soln->val), 
               ((int [4]){a, (-b + (2 * (a + c + d))), c, d}),
               (4*sizeof(int)));
        llaAppend(solutions, soln);
    }
    if ((-c + (2 * (a + b + d))) > c) {
        soln = nodeArrayInit();
        memcpy((soln->val), 
                ((int [4]){a, b, (-c + (2 * (a + b + d))), d}),
                (4*sizeof(int)));
        llaAppend(solutions, soln);
    }
    if ((-d + (2 * (a + b + c))) > d) {
        soln = nodeArrayInit();
        memcpy((soln->val), 
                ((int [4]){a, b, c, (-d + (2 * (a + b + c)))}),
                (4*sizeof(int)));
        llaAppend(solutions, soln);
    }

    return solutions;
    */
}

/**
 * input:  quadList (a list of quadruples)
 *         ceiling (the arbitrary limit we don't want to go above)
 * output: validQuads (list of quadruples where every curv is below the ceiling)
 */
/*
struct LinkedListArray* check(struct LinkedListArray *quadList, int ceiling) {

    struct LinkedListArray *validQuads = llaInit();
    struct NodeArray *validQuad = NULL;
    struct NodeArray *quadrupleNode = NULL;
    int entry;
    int quadruple[4];
    bool valid = true;

    for (quadrupleNode = quadList->header; quadrupleNode != NULL; quadrupleNode = quadrupleNode->next)
    {
        valid = true;

        // Copy array in quadrupleNode to quadruple
        memcpy(quadruple, 
                quadrupleNode->val,
                4*sizeof(int));
        for (entry = 0; entry < 4; entry++)
        {
            if (quadruple[entry] >=ceiling)
            {
                valid = false;
            }
        }
        if (valid) {
            validQuad = nodeArrayInit();

            // Copy quadruple array to validQuad node
            memcpy(validQuad->val, 
                    quadruple,
                    4*sizeof(int));
            llaAppend(validQuads, validQuad);
        }
    }

    return validQuads;
}
*/

/**
 * input:  root (the initial quadruple that defines the packing)
 *         limit (arbitrary limit we don't want to go above)
 * output: ancestors (list of quadruples all below the limit)
 */
struct LinkedListArray* fuchsian(int root[4], int limit) {

    struct LinkedListArray *ancestors = llaInit();
    llaAppend(ancestors, nodeArrayInitWithArray(root));

    while (ancestors->len > 0)
    {
        llaExtend( ancestors, transform((llaPop(ancestors)->val), limit) );
    }

    return;
    /*
    struct NodeArray *parent = NULL;
    struct NodeArray *child = NULL;
    for (parent = ancestors->header; parent != NULL; parent = parent->next)
    {
        int parentArray[4];
        memcpy(parentArray,
                parent->val,
                4*sizeof(int));
		// TODO: We need to remove parentArray from *ancestors after we transform(*ancestors)
        struct LinkedListArray *nextGen = transform(parentArray); // TODO: We can combine transfrom and check
        struct LinkedListArray *validGen = check(nextGen, limit);
        for (child = validGen->header; child != NULL; child = child->next)
        {
            struct NodeArray *childCopy = nodeArrayInit();
            memcpy(childCopy->val,
                    child->val,
                    sizeof(child->val));
            llaAppend(ancestors, childCopy);
        }
        free(nextGen);
        free(validGen);
    }

    return ancestors;
    */
}

hashset_t valuesOf(struct LinkedListArray* quadList) {

    struct NodeArray *ruple = NULL;
    hashset_t possible = hashset_create();
    int i;
    for (ruple = quadList->header; ruple != NULL; ruple = ruple->next)
    {
        for (i = 0; i < 4; i++)
        {
            hashset_add(possible, (ruple->val[i]));
        }
    }

    return possible;
}

// Only returns solutions, not an updated orbit because orbit is actually modified in this function since it's a pointer
struct LinkedListArray* transformOrbit(int quad[4], struct LinkedListArray* orbit) {
    
    struct LinkedListArray *solutions = llaInit();
    int a = quad[0], b = quad[1], c = quad[2], d = quad[3];
    int family[4][4];
 
    int aPos = (-a + (2 * (b + c + d))) % 24;
    int bPos = (-b + (2 * (a + c + d))) % 24;
    int cPos = (-c + (2 * (a + b + d))) % 24;
    int dPos = (-d + (2 * (a + b + c))) % 24;

    // This ensures that the results from mod 24 above are positive
    aPos = aPos < 0 ? aPos + 24 : aPos;
    bPos = bPos < 0 ? bPos + 24 : bPos;
    cPos = cPos < 0 ? cPos + 24 : cPos;
    dPos = dPos < 0 ? dPos + 24 : dPos;

    // the four matrices
    family[0] = (int [4]){aPos,   b % 24, c % 24, d % 24};
    family[1] = (int [4]){a % 24, bPos,   c % 24, d % 24};
    family[2] = (int [4]){a % 24, b % 24, cPos,   d % 24};
    family[3] = (int [4]){a % 24, b % 24, c % 24, dPos};

    unsigned int i;
    int match = 1;
    for (i = 0; i < 4; i++)
    {
        struct NodeArray *ptr = NULL;
        for (ptr = orbit->header; ptr != NULL; ptr = ptr->next)
        {
            // If memcmp finds family[i] in orbit, match will be 0, so
            // multiplying by 0 will always give 0, and match will end
            // up as 0.

            match = match * memcmp(family[i], ptr->val, 4*sizeof(int));

        }
        
        // If family[i] was not in orbit, append it to orbit
        if (match != 0)
        {
            llaAppend(orbit, nodeArrayInitWithArray(family[i]));
            llaAppend(solutions, nodeArrayInitWithArray(family[i]));
        }
        
        match = 1;
    }

    return solutions;

}

struct LinkedListArray* genealogy(int seed[4]) {

    struct LinkedListArray *ancestors = llaInit();
    struct LinkedListArray *orbit = llaInit();
    int modSeed[4] = {0};

    unsigned char i;
    for (i = 0; i < 4; i++)
    {
        if ((modSeed[i] = (seed[i] % 24)) < 0)
        {
            modSeed[i] = modSeed[i] + 24;
        }
    }

    llaAppend(ancestors, nodeArrayInitWithArray(modSeed));
    llaAppend(orbit, nodeArrayInitWithArray(modSeed));
    
    struct NodeArray *parent = NULL;
    for (parent = ancestors->header; parent != NULL; parent = parent->next)
    {
        struct LinkedListArray *newGeneration = transformOrbit(parent->val, orbit);
        llaExtend(ancestors, newGeneration);
    }

    return orbit;

}

struct LinkedList* path(struct LinkedList *valList, int top) {

    hashset_t could = hashset_create();

    int i = 0;
    for (i = 0; i < top; i++)
    {
        struct Node *poss = NULL;
        for (poss = valList->header; poss != NULL; poss = poss->next)
        {
            if ((i % 24) == poss->val)
            {
                hashset_add(could, i);
                break;
            }
        }
    }

    return could;

}

struct LinkedList* compare(struct LinkedList *valsPack, struct LinkedList *valsOrb, int limit) {

    struct LinkedList *missing = llInit();
    //printf("About to call path. valsOrb: ");
    llPrint(valsOrb);
    struct LinkedList *should = path(valsOrb, limit);
    //printf("Path results: "); llPrint(should);
    hashset_t valsPackSet = hashset_create();
    struct Node *might = NULL;
    struct Node *ptr = NULL;

    for (ptr = valsPack->header; ptr != NULL; ptr = ptr->next)
    {
        hashset_add(valsPackSet, (ptr->val));
    }

    for (might = should->header; might != NULL; might = might->next)
    {
        if (hashset_is_member(valsPackSet, (might->val)) == 0)
        {
            struct Node *node = nodeInit();
            node->val = might->val;
            llAppend(missing, node);
        }
    }

    return missing;

}

struct LinkedList* seek(int root[4], int cap)
{

    //printf("In seek\n");
    struct LinkedListArray *small = fuchsian(root, cap);
    //printf("  fuchsian results - matches with acp python code \n");
    //llaPrint(small);
    struct LinkedList *valuesPack = valuesOf(small);
    //printf("  valuesOf results from fuchsian - matches with acp python code \n");
    //llPrint(valuesPack);
    struct LinkedListArray *admissible = genealogy(root);
    //printf("  genealogy results - matches with acp python code\n");
    //llaPrint(admissible);
    struct LinkedList *valuesOrbit = valuesOf(admissible);
    //printf("  valuesOf results from genealogy - mathces with acp python code\n");
    //llPrint(valuesOrbit);
    struct LinkedList *gone = compare(valuesPack, valuesOrbit, cap);

    return gone;
}

void main(void) {

    int root[4] = {-1, 2, 2, 3};
    int index = 0;
    int ceiling = 1000000;

    printf("Running seek with root {");
    for (index = 0; index < 4; index++) { printf("%d,",root[index]); }
    printf("} and ceiling %d\n", ceiling);

    struct LinkedList *results = seek(root, ceiling);
    llPrint(results);

}  
